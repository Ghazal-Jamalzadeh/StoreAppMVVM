Timer (verify)--------------------------------------------------------------------------------------
برای نوشتن تایمر روش های مختلفی توی اندروید وجود داره
روشی که ما میخوایم استفاده کنیم اینه:
اندروید یک کلاسی داره به اسم CountDownTimer
یعنی یک عددی رو بهش میدید و میگید چند تا  چند تا بشمره
ما میخوایم 60 ثانیه رو به صورت یک ثانیه یک ثانیه به عقب بشمریم
بعد ما این عدد رو میدیم به پروگرس بار
----------------
برای استفاده از این تایمر ما باید یک بار استارتش کنیم
و نکته خیلی مهم این که فراموش نکنید کنسلش کنید
چون به شمردن ادامه میده همینجور... پرفورمنس رو میاره پایین
همینطور تو جا به جایی بین صفحات باید ریست شه تایمر اگه نه خیلی افتضاح میشه

         return object : CountDownTimer(60_000, 1_000) {
مقدار بازگشتی رو اینجور با آبجکت مینویسن!
توی اندروید همه چیز به صورت دیفالت میلی سکند هست
برای راحت تر خونده شدن اعداد آندرلاین میذاریم

دو تا متد داره که باید ایمپلمنت شن
onTick :
برای هر بار یک واحد میره جلو یک بار اجرا میشه
حالت لیسنر داره
اون عدد جاری رو هم بر اساس میلی ثانیه میده بمون

onFinish :
وقتی شمارش تمام شد صدا زده میشه

دکمه ارسال مجدد حین شمارش نامريی شه موقع پایان دیده شه
شمارنده حین شمارش دیده شود موقع پایان دیده نشود
پروگرس بار حین شمارش دیده شود موقع پایان دیده نشود
عدد رو نمایش میدیم و دایم آپدیت میکنیم

                @SuppressLint("SetTextI18n")
                override fun onTick(millis: Long) {
                    sendAgainBtn.isVisible = false
                    timerTxt.isVisible = true
                    timerProgress.isVisible = true
                    timerTxt.text = "${millis / 1000} ${getString(R.string.second)}"


میایم از setProgressCompat به جای setProgress استفاده میکنیم
چرا؟
چیزایی که کامپت دارن نسبت به تمام نسخه های اندروید بالا و پایین کامپتیبل شدن
بهینه سازی و ...
اگه کامپت میبینین ازش استفاده کنید
پارامتر دومش هم یک بولین هست که true یعنی با حالت انیمیشن این تغییر پروگرس انجام شه
                    timerProgress.setProgressCompat((millis / 1000).toInt(), true)
                    if (millis < 1000)
                        timerProgress.progress = 0
                }

                override fun onFinish() {
                    sendAgainBtn.isVisible = true
                    timerTxt.isVisible = false
                    timerProgress.isVisible = false
                    timerProgress.progress = 0
                }
            }
        }

حالا برای اینکه cpu رو درگیر نکنیم که هم زمان که داره پروسه رندر کردن صفحه رو انجام میده
تایمر رو هم هم زمان استارت بزنه
چه اتفاقی می افته اینجا؟
احتمالا یک لگ ریزی میزنه
برای جلوگیری از این وضعیت
یک دیلی ریز میندازیم بعد تایمر رو استارت میزیم

نکته:
همیشه خودتون خالی کردن رم و متغیرهای به درد نخور رو هندل کنید
تا گاربیج کالکتور مجبور نشه بیاد وارد عمل شه
چون گاربیج کالکتور که میاد دیگه لگ و هنگ و اینام هس
یه دلیلی که ما بایندینگ ها را نال میکنیم همینه
صفحه ای که یوزر ترکش کرده و قرار نیست برگرده بهش دلیلی نداره توی رم بمونه
مخصوصا موقع استفاده از سرویس ها مثل اس ام اس ریسیور
مثل تایمر

Count Down Timer (Discounts)------------------------------------------------------------------------------
قبلا توی صفحه وریفای تایمر استفاده کرده بودیم که توضیحاتش بالاتر هست
یک دیقه رو به صورت معکوس میشمرد

حالا توی تخفیف ها:
ما یک تاریخی داریم توی فرمت زیر
2024-03-19T09:37:00.000000Z
که توی فیلد end_time از api میاد

ما توی تایمر به لانگ نیاز داریم
پس این رو باید به لانگ تبدیل کنیم در قدم اول

ما باید از تایم استمپ استفاده کنیم
اینو تبدیل کنیم به تایم استمپ و بدیمش به کانت داون تایمر
چطور تبدیلش کنیم به تایم استمپ؟
خیلی راحته

اگه بک اند دولوپر به ما تایم استمپ بده یک مرحله کارمون جلو می افته
ولی حالا نداده خودمون باید این مرحله رو بریم
ولی اکثرا دیت رو به این شکل میدن و تایم استمپ نمیدن

تاریخ امروز رو هم به صورت تایم استمپ لانگ به دست میاریم
بعد این دو تا رو از هم کم  میکنیم
عدد به دست آمده میشه اون زمان باقی مانده تا تخفیف

اون تاریخی که از سمت سرور میاد رو به صورت ورودی توی این فانکشن میگیریم
    private fun discountTimer(fullDate: String) {

حالا میخوایم این تاریخو تبدیل کنیم به تایم استمپ
برای تبدیلش باید پترن دیت رو به دست بیاریم
2024-03-19 -> yyyy-MM-dd
سال وای کوچیک هست توی این استاندارد (استاندارد جهانیه و مربوط به اندروید نیست)
ماه ام بزرگ هست
ام کوچیک برای دقیقه استفاده میشه
روز هم دی کوچیک هست
ساعت اچ بزرگ است
دقیقه ام کوچیک
ثانیه هم اس
این پترن رو توی یک متغیر میرریزیم
از کلاس SimpleDateFormat استفاده میکنیم
ممکنه بک اند دولوپر شما مثلا پس و پیش بده این ترتیبو. خودتون فرمت رو اصلاح کنید
یا کاراکترا مثلا جا دش اندرلاین باشه...
        val formatter = SimpleDateFormat("yyyy-MM-dd", Locale.ENGLISH)

اینجا تبدلیش میکنیم به دیت یا تاریخ
این کلاس دیت توی اندروید میاد پیاده سازی عملیات های مختلف مربوط به تاریخ رو انجام میده
        val date: Date = formatter.parse(fullDate) as Date

زمان الان رو به دست میاریم در قالب تایم استمپ
سال  ماه تا ساعت ثانیه و میلی سکند الان رو میده بمون
        val currentMillis = System.currentTimeMillis()

حالا ما به دیت تبدیل کرده بودیم اونو
میایم تایم اون رو هم میگیریم
این تایم استمپ رو میده بمون
این دو تا رو از هم کم میکنیم
        val finalMillis = date.time - currentMillis

حالا این عددی که به دست آوردیم همون عددیه که میخوایم
میدیمش به کان داون تایمرمون
و یک ثانیه یک ثانیه میشمره میره عقب
 countDownTimer = object : CountDownTimer(finalMillis, 1_000) {

            override fun onTick(millisUntilFinished: Long) {

 این محاسبات رو کاتلین خیلی راحت برای ما انجام داده
 توی جاوا باید کلی مینوشتیم
 به منها ها دقت کنید
 کلا محاسباتش این شکلیه که
 زمان باقی مانده رو به میلی سکند داریم
 میایم تبدیلش میکنیم به روز
 این روزها رو باید نشون بدیم به کاربر
 بعد میایم این روزها رو از کل زمان کم میکنیم
 حالا زمان باقی مونده رو به ساعت تبدیل میکنیم
 ...الی آخر
                //Calculate time
                var timer = millisUntilFinished
                val day: Long = TimeUnit.MILLISECONDS.toDays(timer)
                timer -= TimeUnit.DAYS.toMillis(day)
                val hours: Long = TimeUnit.MILLISECONDS.toHours(timer)
                timer -= TimeUnit.HOURS.toMillis(hours)
                val minutes: Long = TimeUnit.MILLISECONDS.toMinutes(timer)
                timer -= TimeUnit.MINUTES.toMillis(minutes)
                val seconds: Long = TimeUnit.MILLISECONDS.toSeconds(timer)
                //View
                try {
                    binding.timerLay.apply {
                        if (day > 0) {
                            dayLay.isVisible = true
                            dayTxt.text = day.toString()
                        } else {
                            dayLay.isVisible = false
                        }
                        hourTxt.text = hours.toString()
                        minuteTxt.text = minutes.toString()
                        secondTxt.text = seconds.toString()
                    }
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }

            override fun onFinish() {
            // do nothing
            }
        }