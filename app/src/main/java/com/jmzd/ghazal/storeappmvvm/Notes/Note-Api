Swagger---------------------------------------------------------------------------------------------
https://shop.nouri-api.ir/documentation-api

ساختاری که به طور کلی برای کال کردن api نیاز داریم
1- api services
2- models
3- retrofit configs
4- NetworkRequest : handle requests (success - error - loading - ...)
5- Network Responses : (200 -> data - 422 -> handle dynamic errors - ....)
6- Internet connection checker

Retrofit configs-------------------------------------------------------------------------------------
SerializeNulls------------------------------------
ما جیسون رو تو پایه ترین حالت به این شکل میساختیم
GsonBuilder().setLenient().create()
حالا میخوایم بگیم که نال رو هم سریالایزد کنه و این ها
GsonBuilder().setLenient().serializeNulls().create()
یعنی چی؟
یعنی اون موارد نالی که توی سریالایزد کردن مدل به وجود میاد
مخصوصا برای ارسال کردن رو
من میتونم این اجازه رو بهت بدم که تو بتونی اون فیلد رو نال بفرستی
حالا جلوتر این رو با یک روش خیلی پیشرفته تری هم یاد میگیریم
یعنی این تنها روش نیست و روش های دیگری هم هست

TimeOuts----------------------------------------
که به صورت پیش فرض توی رتروفیت ۱۰ ثانیه هست
که برای اینترنت ایران بچه بازیه
این تنظیمات رو توی client میدیم بهش

retryOnConnectionFailure-------------------------
اگه به failure خورد خودش یک دور دیگه تست کنه قبل ارور دادن

pingInterval-------------------------------------
پینگ میدونید چیه
اون مدت زمانیه که من کلاینت مدت زمانی که طول میکشه تا بتونم با سرور در ارتباط باشم
یعنی مدت زمانی که وقتی به سرور درخواست میفرستم سرور بتونه جوابم رو بده
این برای مواردی کاربرد داره که اگه پینگ ما نتیجه نگرفت یاد یه دور دیگه امتحان کنه
پینگو که بگیریم دیگه مطمعنیم که سرور به ما جواب داده
حالا توی یک ثانیه یا یک دیقه
حالا اینجا میایم تعداد پینگی که این میفرسته و منتظر جواب میشه رو مشخص میکنه
برای اینکه مطمعن شیم اصلا سرور ما رو پاس یا نه
شاید از بیخ پایینه
این هیچ ربطی به ارورهای سرور نداره
چون اصلا با سرور ارتباط نداریم در این حالت
آیا سرور به من جواب میدهد یا خیر؟
ما این عملیات اینتروال پینگ رو روی ۳ ثانیه تنظیم میکنیم
اگه تو این بازه هیچ پینگی نگرفتیم یعنی سرور خرابه
ریسپانس شاید دیر بیاد حتی تا یک دیقه طول بکشه ولی پینگ فرق داره و بالای ۳ ثانیه یعنی افتضاح

Headers-----------------------------------------
اگه بخوایم یک هدری توی همه ریکوعست ها بره توی همین okhttpClient میدیم باز
توی این قسمت میخوایم مدیریت کردن هدرها به بهترین شکل ممکن رو یاد میگیریم
تا اینجا یاد گرفتیم چطور اطلاعات روی توی path و body و کوعری سمت سرور بفرستیم
هدر هم همینه و برای فرستادن اطلاعات سمت سرور هست
ولی به چه دردی میخوره؟
هدرها قبل از بادی و کوعری و path فرستاده میشن سمت سرور
یعنی بالاتر از همه اون بالا تو اول ریسپانس فرستاده میشن سمت سرور
مثلا اینکه اطلاعات رو جیسون بفرستیم
(چون روش های دیگه ای مثل xml هم هست مه بهترین روشش همین جیسونه که اصلاحا رست فول api هم میگن)
گاهی وقتا پیش میاد که بک اند دولوپر ارورها رو به شکل های مختلفی برای ما میفرسته
مثلا جیسون - html یا ...
ما که وب نیستیم بتونیم html رو رندر کنیم و نشون بدیم
میخوایم بگیم اگه ارور داشتی به صورت جیسون برای من بفرست چون من جیسون رو میفهمم
این یکی از کاربردهاشه
کاربرد مهم تر اینه که میگه من کی ام
احراز هویت جایی غیر از هدر کاملا غیر اصولیه

روش های مختلفی برای ارسال هدر توی ریکوعست وجود داره:
1- @Header
به صورت جداگانه در هر ریکوعست
suspend fun postLogin(@Header("token") token : String , @Body body : BodyLogin) : Response<ResponseLogin>
برای پروژه های بزرگ مناسب نیست
و بیش از یک هدر هم نمیشه ارسال کرد

2- @Headers
    @Headers("ACCEPT : APPLICATION/JSON" , "..." , "...")
    @POST("auth/login")
    suspend fun postLogin(@Body body : BodyLogin) : Response<ResponseLogin>
قابلیت فرستادن چندین هدر داره ولی به ازای تمام اند پوینت ها دايم در حال تکرار شدن هست

3- retrofit configs
باز اینجا روش های مختلفی وجود داره برای هندل کردن هدر که ما همه ش رو نمیگیم. بهترینشو میگیم
قبلا یاد گرفتیم که در قالب اینترسپتور میتونیم اطلاعات مختلفی رو به ریکوعست اضافه کنیم
مثل لاگ گرفتن
ارسال هدر توی همه درخواست ها هم میشه باش انجام داد
چیزایی که توی کانفیگ رتروفی میزنیم کلا روی همه درخواست ها سوار میشه

logger interceptor--------------------------
باز اینجا میخوایم پیشرفته تر از پروژه های قبلی بزنیم اینو
اگه کلا api رو به صورت بادی بفرستیم
هر کی گوشی رو به اندروید استدیو وصل کنه میتونه لاگای ما رو بخونه
پس ما میخوایم بهش بگیم موقع تست اپ لاگ همه اینترسپتورها رو بده به من
زمانی که از حالت تست در اومد دیگه لاگ ننداز
اپ رو سنگین میکنه اصلا و باعث پر شدن کش اپلیکیشن میشه
که به شکل زیر هندل میکنیم
level = if (BuildConfig.DEBUG) HttpLoggingInterceptor.Level.BODY else HttpLoggingInterceptor.Level.NONE

add multiple interceptors----------------------
قبلا یک اینترسپتور تعریف میکردیم
.addInterceptor(interceptor)
اینجوری اضافه میکردیم به رتروفیت
حالا میخوام چند تا اینترسپتور داشته باشم
که به روش بالا نمیشه
            .addInterceptor { chain: Interceptor.Chain ->

            }
اینجوری میشه در نهایت

            .addInterceptor { chain: Interceptor.Chain ->
                val token = runBlocking {
                    sessionManager.getToken.first().toString()
                }
                chain.proceed(chain.request().newBuilder()
                    .also {
                        it.addHeader(AUTHORIZATION, "$BEARER $token")
                        it.addHeader(ACCEPT, APPLICATION_JSON)
                    }.build())
            }
            .also { client ->
                client.addInterceptor(loggingInterceptor)
            }
از also استفاده میکنیم چون چند تا هدر میخوایم بفرستیم
اگه یکی بود همینو بدون also مینوشتیم
            chain.request().newBuilder().addHeader(...)

هدر هم که کلا به صورت key/value هست

دسترسی به توکن در اینترسپتور-------------------------
چون کلاس سشن منیجر ما ساسپند هست
باید یا ساسپند باشه یا داخل لایف سایکل اسکوپ
که به هیچ کدوم توی ماژول دسترسی درستی نداریم
پس چیکار میکنیم؟
runBlocking
میاد یک لحظه ui ما رو فریز میکنه تا کارشو انجام بده
این عملیات هم در حد میلی ثانیه طول میکشه. اصلا دیده نمیشه

--------------------------------------------


Login-----------------------------------------------------------------------------------------------
میتونیم پارامتر هش کد رو نفرستیم. اکه نفرستادیم نمیتونیم انتظار اوتو دیتکت اس ام اس رو داشته باشیم
توی فیلد اولش هم باید یا شماره موبایل بفرستیم یا ایمیل

Response body:
{
  "time": 90,
  "isEmail": 0,
  "ex": 0
}

Error body:
میتونه تو یکی از فرمت های زیر بیاد:
----------------------
{
  "success": false
}
----------------------
{
  "message": "The given data was invalid.",
  "errors": {
    "login": [
      "ایمیل یا شماره موبایل نامعتبر است."
    ]
  }
}
------------------------
دقت کنید این فیلدی که با کلید login اومده ثابت نیست و میتونه با هر اسم دیگه ای بیاد
بسته به فیلدی که ارور داره
جلوتر یاد میگیریم چطور این فیلدها رو به صورت داینامیک بخونید
خیلی خیلی حرکت خفن و کمیابیه
-------------------------
موقع ساخت مدل دقت کنید که بعضی از اندپوینت ها ممکنه چندین مدل داشته باشن
چون چندین رسپانس دارن
مثلا یکی برای ارور یکی برای ساکسس و یکی برای بادی که خودمون سمت سرور میفرستیم
برای همین پکیج بندی خیلی به نظم کدمون کمک میکنه
-------------------------

Verify----------------------------------------------------------------------------------------------
بادی ای که توی این api قراره بفرستیم سمت سرور تا حدی شبیه بادی لاگین هست
کافیه دو تا فیلد بیشتر بهش اضافه شه و لاگین هم بینشون مشترک
data class BodyLogin(
    @SerializedName("login")
    var login: String? = null, //09120174757
    @SerializedName("hash_code")
    var hashCode: String? = null, //hjfvhzdbg#+
)

خب روش آماتورش ساخت دو تا مدله. ولی ما میخوایم جفتشو تو یکی هندل کنیم
خودمون با دست فیلدهای جدیدش رو اضافه میکنیم
---------------------
یک فیلدی داریم توی رسپانس ساکسس به شکل زیر
 "expires_in": 13046400,
 این چیه؟
 به این میگن تایم استمپ
 تو گوگل سرج کنید آنلاین تایم استمپ کانورتر کلی میاره
 از سال تا ثانیه توش هست
 کلی الگوریتم آماده برای تبدیلش وجود داره
 search: convert timestamp to date in java / kotlin
 تبدیلش هم دو طرفه ست. یعنی هم تاریخ به راحتی تبدیل به تایم استمپ میشه هم برعکس
 اکثر بک اند دولوپرها با تایم استمپ کار میکنن
