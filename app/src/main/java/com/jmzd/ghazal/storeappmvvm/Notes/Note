Android studio short cuts---------------------------------------------------------------------------
Ctrl + ALT + O = remove unnecessary imports (optimize imports)

Ctrl + alt + +/- = open/close a specific block of code
Ctrl + shift + +/- = open/close all blocks of code in a page

LogCat----------------------------------------------------------------------------------------------
برای فیلتر کردن لاگ های مثلا ارور در اندروید استدیو جدید میتونید از کلمات کلیدی مختلف استفاده کنید
برای فیلتر کردن نوع خاصی از لاگ از level استفاده کنید

Dependencies----------------------------------------------------------------------------------------
Data Binding:
خودمون استفاده ای ازش نداریم ولی یکی از کتتابخانه هایی که اد کردیم نیازش داره

Coli & Glide:
بین کتابخانه های لود عکس در اندروید بهترین پرفورمنس مال گلاید هست
مزیت کویل اینه که صد در صد کاتلینیه و با کروتین ها خیلی مچه
کوبل با کروتین ساخته شده کاملا ولی گلاید سازوکار خاص خودشو داره
و زمانی که گلاید عرضه شد خطای out of memory رو تا ۸۰ درصد کاهش داد
مثل رتروفیت یک کتابخونه انقلابی بود

PinView:
برای وارد کردن اعداد کد تایید و...

MP Android Chart:
بزرگترین کتابخونه رسم نمودار برای اندروید هست
تقریبا هر مدل نموداری بخوایم داره
حتی نمودارهای کاستوم میتونید بسازید
بلا استثنا تمام پروژه های بزرگ از این کتابخانه استفاده میکنن

Application class-----------------------------------------------------------------------------------
برای معرفی هیلت و کالی گرافی
(res -> RClick -> new folder -> assetFolder -> insert font here)

Data Store-------------------------------------------------------------------------------------------
میتونیم کلاس مربوط به دیتا استور رو توی پکیج یوتیلز یا دیتا قرار بدیم و هر دو درسته کاملا
ما میایم میذاریم توی دیتا چون میگیم کار با دیتاست دیگه
براش هم یک پکیج می سازیم به اسم stored

ما از لفظ سشن برای کارهای مربوط به توکن و واحراز هویت استفاده میکنیم
سشن چیه؟
توی هر پلتفرمی که باشید یک فضایی برای شما در نظر میگیرند
که شما توی اون فضا می تونید وجود داشته باشید
اطلاعاتت رو دارن و میدونن شما چه شخصی هستید
پلتفرم ها میان برای این سشن ها یک اکسپایر تایم یا زمان منقضی شدن در نظر میگیرن
مثلا دو ساعت - دو هفته - دو ماه
هر از گاهی میندازمت بیرون دوباره لاگین کن
که این یک چیز کاملا عرفیه

دیتا استور یک دیتابیس مانندیه که میاد توی یک فایلی از جنس xml ذخیره میکنه دیتای ما رو

    companion object{
        /* دقت کنید روی کلاس کانتکس تعریف کنید نه آبجکت کانتکس */
        /* این خط کد میاد میاد خود فایل اون چیزی که داره درست میشه رو برامون درست میکنه
        * شبیه اسم دیتابیس توی روم */
        private val Context.dataStore : DataStore<Preferences> by  preferencesDataStore(SESSION_AUTH_DATA)
        /* این خط کد میاد دیتای داخل اون فایل رو برامون ذخیره میکنه
        * شبیه اسم تیبل توی روم */
        private val tokenKey = stringPreferencesKey(USER_TOKEN_DATA)
    }

این نکته رم دقت کنید:
زمانی که از دیتااستور استفاده می کنید
دیتا استور به ازای هر یک از کلیدها باید یک بار ساخته شود
اکه توی کامپنین ابجکت قرار ندید مدام میخواد بسازه
و با ارور رو به رو میشید
پس یا باید به صورت سینگل تون بسازید یا کامپنین آبجکت باشه حتما

برای دریافت توکن از کد زیر استفاده میکنیم
    val getToken : Flow<String?> = appContext.dataStore.data.map { data: Preferences ->
        data.toString()
    }
میخوام به صورت فلویی از استرینگ باشه که بتونم کالکتش کنم
ولی وقتی میزنیم دیتا استور دات دیتا یک فلویی از پرفرنسیز میده بمون
خب پس مپ میزنیم که بتونیم تبدیل کنیم

-----------------------------------------------
برای استفاده از مقادیر ذخیره شده در دیتا استور در فرگمنت (اسپلش)
بعد از تزریق وابستگی های لازم:
میتونیم از کالکت استفاده کنیم
                val token = sessionManager.getToken.collect{ value : String? ->
                    value
                }
یا نه یک روش بهتر میتونیم از فرست استفاده کنیم:
مزیتش چیه؟
میگه زمانی که اون چیزی که تو میخوای رو در اختیارت قرار داد
بلافاصله اون کالکشن رو میاد کنسل میکنه
ما صرفا تو اسپلش میخوایم چک کنیم همچین محتوایی موجوده با نه
نمیخوایم گوش به زنگ تغییرات باشیم که

                val token : String? = sessionManager.getToken.first()


این روش مدیریت کردن سشن (یعنی با یک کلاس جداگانه) یکی از بهترین روش های مدیریت سشن هست که تا حالا توی این دوره انجام دادیم

Navigation------------------------------------------------------------------------------------------
res -> RClick -> new android resource directory -> navigation

توی این پروژه یاد میگیریم که چطور نویگیشن های تو در تو استفاده کنیم

Lottie----------------------------------------------------------------------------------------------
res -> RClick -> new android resource directory -> raw -> insert your animation here

then use it like this :

    <com.airbnb.lottie.LottieAnimationView
        android:id="@+id/animationView"
        android:layout_width="match_parent"
        android:layout_height="@dimen/_180mdp"
        android:layout_marginTop="@dimen/_10mdp"
        app:lottie_autoPlay="true"
        app:lottie_loop="false"
        app:layout_constraintTop_toBottomOf="@id/infoTxt"
        app:lottie_rawRes="@raw/lottie_phone" />

Hilt named and qualifiers---------------------------------------------------------------------------
کوالیفایرها که یکم سختن و باید فایل جدا براشون ساخت و این ها
برای named ها
چون هیلت از روی دیتا تایپ تشخیص میده چیزا رو
وقتی مثلا دو تا لانگ داریم باید یکیش نیمد باشه
وقتی ۱۰ تا لانگ داریم باید ۹ تاش نیمد باشه

Handle Dynamic Errors-------------------------------------------------------------------------------
توی کلاس NetworkResponse توی ارور 422 ممکنه با ارورهای داینامیک رو به رو شیم که فیلد رو در قالب کلید میفرستن برامون
{
  "message": "The given data was invalid.",
  "errors": {
    "login": [
      "ایمیل یا شماره موبایل نامعتبر است."
    ]
  }
}

دقت کنید هر چیزی ۲۰۰ نباشه در قالب ارور بادی برمیگرده بدنه ش (اگر بدنه داشته باشه)

            response.code() == 422 -> {
                var errorMessage = ""
                if (response.errorBody() != null) {

اول از همه جیسون رو تبدیل میکنیم به جی سان تا بتونیم به موارد مختلفش دسترسی داشته باشیم
پارامتر اولش بدنه ارور ما هست
که از ارور بادی میگیریم و charSequence ش میکنیم
پارامتر دوم میگه به چی تبدیلش کنم؟
                    val errorResponse = Gson().fromJson(response.errorBody()?.charStream(), ErrorResponse::class.java)

دسترسی به فیلد مسیج به این شکل هست که ما فعلا استفاده ش نمیکنیم
                    //val message = errorResponse.message

دسترسی به اون مپی که برای ارورز تعریف کردیم که فیلد داینامیک ما هست
                    val errors = errorResponse.errors
خب تا اینجای کار ما به اون مپه دسترسی پیدا کردیم. حالا دم بعدی چیه؟

ما خیلی راحت میتونیم مپ رو با فور ایچ پیمایش کنیم
پارامتر اولش key رو به ما میده و پارامتر دومش value
                    errors?.forEach { (key : String, value: List<String>) ->

نکته ای که اینجا هست اینه که ما لیست استرینگ هست ولیو هامون ولی استرینگ میخوایم
برای اینکه کاربر این کروشه ها رو نبینه []
خود لیست یک دستوری داره به اسم joinToString
کروشه اینا رو خودش پاک میکنه و یک استرینگ تمیز میده بمون
دستورات بیشتری هم برای کاستومایز بیشتر میتونیم بزنیم توش
                        errorMessage = value.joinToString()
                    }

                }

در نهایت ارور رو در قالب نتورک ریکوعست میدیم بیرون
                NetworkRequest.Error(errorMessage)
            }

ViewModel & LiveData--------------------------------------------------------------------------------
کار جدیدی که در این پروژه کردیم استفاده از انکپسولیشن در لایو دیتاهاست
همچنین ویومدل رو قبلا به این شکل تعریف میکردیم توی صفحه
    private val viewModel : LoginViewModel by viewModels()
    private val viewModel by viewModels<LoginViewModel>()
عینا شبیه هم هستن و برتری خاصی به هم ندارن اصلا

-------------------------------------------------------------------------تزریق وابستگی در دیتا کلاس ها
فرض کنید این کلاس رو داریم و میخوایم بتونیم تزریقش کنیم
data class BodyLogin(
    @SerializedName("login")
    val login: String?, //09120174757
    @SerializedName("hash_code")
    val hashCode: String?, //hjfvhzdbg#+
)

روش اول :
data class BodyLogin @Inject constructor(
    @SerializedName("login")
    val login: String?, //09120174757
    @SerializedName("hash_code")
    val hashCode: String?, //hjfvhzdbg#+
)

روش دوم: (اصولی تر)
بهتره بیایم این ها رو در قالب یک ماژول در نظر بگیریم
چرا؟
چون یک سری دیتا دارن معمولا که باید توی ورودی بهشون بدیم
مجبور نباشیم دستی هندل کنیم
به این منظور FragmentModule رو می سازیم
لایف سسایکل این ماژول هم به جای سینگل تون فرگمنت خواهد بود
دقت کنید چون باید مقداردهی اولیه صورت بگیرد مقادیر var بوده و مقدار اولیه null رو میدیم

extensions------------------------------------------------------------------------------------------
یک نکته ی نهایت مهم و کمیاب درمورد اکستنشن فانکشن ها
اگر اکستنشن فانکشنی رو دارید می نویسید که کارهای نسبتا سنگین تری رو داره انجام میده
و کدهای زیادی داره و روی ui کار میکنه
بهتره به صورت جداگانه نوشته شه
اکستنشن های  کوچیک و سبک رو توی همون فایل جنرال اکستنشن ها بنویسید

hide keyboard-----------------------------
fun View.hideKeyboard() {
    val imm = context.getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager
    imm.hideSoftInputFromWindow(windowToken, 0)
}
context :
وقتی اکستنشنن رو روی ویو مینویسیم خیلی راحت ببا کلمه context به کانتکس هم دسترسی داریم

getSystemService :
دسترسی به حالت هایی که توی سیستم من به عنوان سرویس وجود دارن

INPUT_METHOD_SERVICE :
یکی از این حالت ها اینپوت متد من هست که مربوط به کیبورد است
برای دسترسی بهش به کلاس کانتکس نیاز داریم

as InputMethodManager :
تبدیلش میکنیم به  InputMethodManager

windowToken :
توسط ویو بهش دسترسی داریم
 به همون صفحه ای که داریم باهاش کار میکنیم اشاره میکند

0 :
فلگ صفر کیبورد رو میبنده

Sealed class----------------------------------------------------------------------------------------
چون تما زیر مجموعه های سیلد کلاس از همون سیلد کلاس ساختته شدن با is میتونیم مقایسه کنیم
از is زمانی میتونیم استفاده کنیم که ارث بری صورت گرفته

Internet Connection Checker-------------------------------------------------------------------------
توی این دوره حال های مختلفی از چک کردن کانکشن رو گفتیم
حرفه ای ترین حالتیش اون حالتی بود که توی رسپی کدش رو زدیم
اینجا هم از همون استفاده میکنیم
بعد یاد میگیریم چطور از اون چیزی که اینترنت رو چک میکنه توی همه فرگمنت ها استفاده کنیم
یعنی مثل مثال های قبلی به صورت جداگانه توی هر فرگمنت استفاده نکنیم

این کلاس توی پروژه رسپی یک دور کامل توضیح داده شده
اینجا مجدد توضیح میدیم
1-
گفتیم برای اینکه بتونم اتصال به اینترنت رو چک کنم به دو تا چیز نیاز دارم
کانکتیویتی منیجر که توسط کانکتیویتی منیجر میتوننم حالت های مختلف اون کانکشن رو به دست بیارم
نتورک ریکوعست که به وسیله اون میتونم  چیزای مربوط به اینترنت رو هندل کنم
پس این دو تا رو داخل سازنده اینجکت میکنیم

2-
بعد برای اینکه بتونیم به موارد منیجر دسترسی داشته باشیم
 و متدهاش رو ایمپلمنت کنیم از ConnectivityManager.NetworkCallback() ارث بری میکنیم

3-
اگه یادتون بیاد ما به دو تا متغیر هم نیاز داشتیم

یکی برای اینکه آخرین اینکه اینترنت هست یا نه رو در قالب بولین برامون نگه میداره
از نوع MutableStateFlow تعریفش میکنیم. چرا؟
چون هم به صورت فلو ببریمش جلو
هم هر موقع تغییری داشت بتونیم اعمال کنیم

بعد از اون هم نیاز به یک متغیری داشتیم به اسم capabilities که از نوع کلاس NetworkCapabilities
چکار میکردیم باش؟
برای این بود که بفهمم اینترنت الان روی وای فایه یا دیتا یا چی

4-
بعد از تریف موارد بالا به چه جیزی نیاز داشتیم؟
به یک فانکشنی نیاز داشتیم که کل عملیات اینترنت داخل اون اتفاق می افته
که خروجیش هم  MutableStateFlow<Boolean> هست

5-
        manager.registerNetworkCallback(request, this)
میایم کال بک های مورد نیازمون توی منیجر رو رجیستر میکنیم
پارارمتر اول همون ریکوعست هست که به عنوان پارامتر دوم کانستراکتور گرفتیم
پارامتر دوم همون چیزیه که ازش ارث بری کردیم پس this میدیم بهش

6-
توی این مرحله اگه پرمیشن دسترسی اینترنت رو اضافه نکردیم اضافه میکنیم توی مانیفست

7- Init network :
برای اینکه چک کنیم حالا اینترنت وصله یا نیست و این ها
اکه یادتون بیاد ما از دو روش استفاده کردیم
اندرویدهای ۶ به بالا و ۶ به پایین
میایم چک میکنیم به چی وصلیم و این ها و بر اساس اون اون استیت فلوی بولین رو مقداردهی میکنیم

8-
دو تا متد دیگه هستن که میایم اورراید کنیم تا استفاده کنیم
برای قطعو وصل شدن اینترنت
onAvailable
onLost

check connectivity in fragment----------------------------------------------------------------------
چیکار کنیم که یک بار بنویسیم و تو همه فرگمنت ها اعمال شه
برای این کار میایم یک فرگمنت بیس درست میکنیم و همه فرگمنت ها از اون ارث بری میکنن
اینترنت رو توی اون فرگمنت بیس هندل مکینیم

BaseFragment----------------------------------------------------------------------------------------
بیس فرگمنت رو به صورت ابسترکت مینویسیم
Wow....

CustomView------------------------------------------------------------------------------------------
میخوایم برای دکمه هامون یک حالت کاستوم برای لودینگ ایجاد کنیم
البته کاستوم ویو نمی نویسیم
میایم یک اکسستنشن فانکشن برای لودینگش مینویسیم
اینم یک راهشه دیگه...

private fun drawableProgress(context: Context): Drawable? {
اولین کاری که میکنیم یک فانکشنی می نویسیم که بیاد یک ویو درست کنه
زمانی که شما دارید روی ویوها کار میکنید اکثر مواقع یعنی ۸۰٪ به بالا به کانتکست نیاز دارید
بعد میخوایم تبدیلیشش کنیم به Drawable
چرا Drawable؟
چون ما هر چیزی که به عنوان یک shape یا آیکون بخوایم اضافه کنیم باید از Drawable استفاده کنیم
متریال باتن هم در قالب آیکون میگیره این چیزا رو


val value = TypedValue()
اولین چیزی که نیاز داریم یک ولیو هست از نوع TypedValue
تایپد ولیو در واقع میاد اون چیزای مختلفی که روی کاستوم ویو من میخوام اعمال کنم رو
 توسط این میام هندلشون میکنم جلوتر
 مثلا از دیتاش بعدا استفاده میکنیم که دیتای خود پروگرس بار رو متوجه شیم


context.theme.resolveAttribute(android.R.attr.progressBarStyleSmall, value, false)
context.theme :
دسترسی به تم
[در واقع دسترسی به اترییبیوت های xml پیدا میکردم با این کد وقتی خودم کاستوم ویو مینوشتم. توی فایل attrs ...]
اینجا به تم خود اندروید اشاره میکنه
{ تایپ ولیو ها هم تا جایی که یادمه اون نوع اتریبیوت بودن. مثلا Drawable باشه یا بولین یا چی؟}
resolveAttribute :
میگه اون تمت رو به من بده
تمی که میخوای اعمال کنی رو هر ویویی که مد نظرته
progressBarStyleSmall :
اندروید برای پروگرس بار استایل های مختلفی رو در نظر گرفته که ما از این یکی میخوایم استفاده کنیم


val progressStyle = value.data
دیتای داخل اون ولیو رو میگیریم


val attrs = intArrayOf(android.R.attr.indeterminateDrawable)
اون ارتریبیوت خاص رو میگیریم


    val typeArray: TypedArray = context.obtainStyledAttributes(progressStyle, attrs)
    val drawable = typeArray.getDrawable(0)
    خلاصه میسازیمش


    typeArray.recycle()
زمانی که شما کاستوم ویو درست میکنید این کاستوم ویو از ولیو ارث بری کرده
از هر چیزی میتونه ارث بری کنه. مثلا کانسترینت لایوت - ایمیجج ویو - تکست ویو...
این تکست ویو توی اندروید وجود داره ولی من اومدم یک تکست ویو مخصوص به خودم رو درست کردم
چطور اینو میسازه؟
با ریسایکل
یعنی اون چیزو با اون حالت پیش فرضش پاک میکنه و با این حالت جدیدش میسازه
به این کار میگن ریسایکل کردن
اگه اینو ننویسیم با همون قبلیه و پیش فرضش میره جلو


    return drawable
آخر کارم اینو ریترن میکنیم

---------------------------------------------

fun MaterialButton.enableLoading(loading: Boolean) {

    maxLines = 1
چون ممکنه متن طولانی باشه و وقتی لودینگ نمایش داده میشه چند خطی شه که جالب نیست
فقط لودینگ که هست یک خطی شو بعد برگرد به حالت قبل


    iconGravity = MaterialButton.ICON_GRAVITY_END
اینم که مشخصه

    setIconTintResource(R.color.white)
اینم که رنگش

    if (loading) {
حالا اگه لودینگ بود چیکار کن؟

        var drawable = icon
اول از همه نیاز به یک Drawable داریم که باید بسازیمش
از کجا initialize شه این Drawable؟
از اتریببیوت آیکون متریال باتن


        if (drawable !is Animatable) {
            drawable = drawableProgress(context)
            icon = drawable
        }
میگیم اگه Drawableی که داخل آیکون هست از نوع Animatable نبود
بیا از اون متدی که نوشتیم بسازش
کانتکس از کجا آوردیم؟
چون وقتی داریم روی ویو کار میکنیم خیلی راحت به کانتکسش هم دسترسی داریم
اترییوت آیکون رو میایم این آیکونی که باید نشون بدیم رو میریزیم توش


        (drawable as Animatable).start()
استارتش رو میزنیم شروع کنه چرخیدن


        alpha = 0.5f
الفا رو هم کم کن که کاربر بفهمه دیس ایبل شده

    } else {
        icon = null
        alpha = 1.0f
    }
در غیر این صورت
یعنی لودینگ تمام شد
آیکون رو نال کن که دیگه نشون نده
آلفا رو هم برگردون به حالت اولیه



}