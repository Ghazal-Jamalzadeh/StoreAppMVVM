Android studio short cuts---------------------------------------------------------------------------
Ctrl + ALT + O = remove unnecessary imports (optimize imports)

Ctrl + alt + +/- = open/close a specific block of code
Ctrl + shift + +/- = open/close all blocks of code in a page

LogCat----------------------------------------------------------------------------------------------
برای فیلتر کردن لاگ های مثلا ارور در اندروید استدیو جدید میتونید از کلمات کلیدی مختلف استفاده کنید
برای فیلتر کردن نوع خاصی از لاگ از level استفاده کنید

Dependencies----------------------------------------------------------------------------------------
Data Binding:
خودمون استفاده ای ازش نداریم ولی یکی از کتتابخانه هایی که اد کردیم نیازش داره

Coli & Glide:
بین کتابخانه های لود عکس در اندروید بهترین پرفورمنس مال گلاید هست
مزیت کویل اینه که صد در صد کاتلینیه و با کروتین ها خیلی مچه
کوبل با کروتین ساخته شده کاملا ولی گلاید سازوکار خاص خودشو داره
و زمانی که گلاید عرضه شد خطای out of memory رو تا ۸۰ درصد کاهش داد
مثل رتروفیت یک کتابخونه انقلابی بود

PinView:
برای وارد کردن اعداد کد تایید و...

MP Android Chart:
بزرگترین کتابخونه رسم نمودار برای اندروید هست
تقریبا هر مدل نموداری بخوایم داره
حتی نمودارهای کاستوم میتونید بسازید
بلا استثنا تمام پروژه های بزرگ از این کتابخانه استفاده میکنن

Application class-----------------------------------------------------------------------------------
برای معرفی هیلت و کالی گرافی
(res -> RClick -> new folder -> assetFolder -> insert font here)

Calligraphy------------------------------------------------------------------------------------------
1- application class
2- manifest
3- main activity
(میتونیم کدش رو توی هر اکتیویتی به صوررت مجزا بنویسیم ولی میبریم  توی بیس اکتیویتی که اصولی تر باشه)

Data Store-------------------------------------------------------------------------------------------
میتونیم کلاس مربوط به دیتا استور رو توی پکیج یوتیلز یا دیتا قرار بدیم و هر دو درسته کاملا
ما میایم میذاریم توی دیتا چون میگیم کار با دیتاست دیگه
براش هم یک پکیج می سازیم به اسم stored

ما از لفظ سشن برای کارهای مربوط به توکن و واحراز هویت استفاده میکنیم
سشن چیه؟
توی هر پلتفرمی که باشید یک فضایی برای شما در نظر میگیرند
که شما توی اون فضا می تونید وجود داشته باشید
اطلاعاتت رو دارن و میدونن شما چه شخصی هستید
پلتفرم ها میان برای این سشن ها یک اکسپایر تایم یا زمان منقضی شدن در نظر میگیرن
مثلا دو ساعت - دو هفته - دو ماه
هر از گاهی میندازمت بیرون دوباره لاگین کن
که این یک چیز کاملا عرفیه

دیتا استور یک دیتابیس مانندیه که میاد توی یک فایلی از جنس xml ذخیره میکنه دیتای ما رو

    companion object{
        /* دقت کنید روی کلاس کانتکس تعریف کنید نه آبجکت کانتکس */
        /* این خط کد میاد میاد خود فایل اون چیزی که داره درست میشه رو برامون درست میکنه
        * شبیه اسم دیتابیس توی روم */
        private val Context.dataStore : DataStore<Preferences> by  preferencesDataStore(SESSION_AUTH_DATA)
        /* این خط کد میاد دیتای داخل اون فایل رو برامون ذخیره میکنه
        * شبیه اسم تیبل توی روم */
        private val tokenKey = stringPreferencesKey(USER_TOKEN_DATA)
    }

این نکته رم دقت کنید:
زمانی که از دیتااستور استفاده می کنید
دیتا استور به ازای هر یک از کلیدها باید یک بار ساخته شود
اکه توی کامپنین ابجکت قرار ندید مدام میخواد بسازه
و با ارور رو به رو میشید
پس یا باید به صورت سینگل تون بسازید یا کامپنین آبجکت باشه حتما

برای دریافت توکن از کد زیر استفاده میکنیم
    val getToken : Flow<String?> = appContext.dataStore.data.map { data: Preferences ->
        data.toString()
    }
میخوام به صورت فلویی از استرینگ باشه که بتونم کالکتش کنم
ولی وقتی میزنیم دیتا استور دات دیتا یک فلویی از پرفرنسیز میده بمون
خب پس مپ میزنیم که بتونیم تبدیل کنیم

-----------------------------------------------
برای استفاده از مقادیر ذخیره شده در دیتا استور در فرگمنت (اسپلش)
بعد از تزریق وابستگی های لازم:
میتونیم از کالکت استفاده کنیم
                val token = sessionManager.getToken.collect{ value : String? ->
                    value
                }
یا نه یک روش بهتر میتونیم از فرست استفاده کنیم:
مزیتش چیه؟
میگه زمانی که اون چیزی که تو میخوای رو در اختیارت قرار داد
بلافاصله اون کالکشن رو میاد کنسل میکنه
ما صرفا تو اسپلش میخوایم چک کنیم همچین محتوایی موجوده با نه
نمیخوایم گوش به زنگ تغییرات باشیم که

                val token : String? = sessionManager.getToken.first()


این روش مدیریت کردن سشن (یعنی با یک کلاس جداگانه) یکی از بهترین روش های مدیریت سشن هست که تا حالا توی این دوره انجام دادیم

Navigation------------------------------------------------------------------------------------------
res -> RClick -> new android resource directory -> navigation

توی این پروژه یاد میگیریم که چطور نویگیشن های تو در تو استفاده کنیم

Hilt named and qualifiers---------------------------------------------------------------------------
کوالیفایرها که یکم سختن و باید فایل جدا براشون ساخت و این ها
برای named ها
چون هیلت از روی دیتا تایپ تشخیص میده چیزا رو
وقتی مثلا دو تا لانگ داریم باید یکیش نیمد باشه
وقتی ۱۰ تا لانگ داریم باید ۹ تاش نیمد باشه

Handle Dynamic Errors-------------------------------------------------------------------------------
توی کلاس NetworkResponse توی ارور 422 ممکنه با ارورهای داینامیک رو به رو شیم که فیلد رو در قالب کلید میفرستن برامون
{
  "message": "The given data was invalid.",
  "errors": {
    "login": [
      "ایمیل یا شماره موبایل نامعتبر است."
    ]
  }
}

دقت کنید هر چیزی ۲۰۰ نباشه در قالب ارور بادی برمیگرده بدنه ش (اگر بدنه داشته باشه)

            response.code() == 422 -> {
                var errorMessage = ""
                if (response.errorBody() != null) {

اول از همه جیسون رو تبدیل میکنیم به جی سان تا بتونیم به موارد مختلفش دسترسی داشته باشیم
پارامتر اولش بدنه ارور ما هست
که از ارور بادی میگیریم و charSequence ش میکنیم
پارامتر دوم میگه به چی تبدیلش کنم؟
                    val errorResponse = Gson().fromJson(response.errorBody()?.charStream(), ErrorResponse::class.java)

دسترسی به فیلد مسیج به این شکل هست که ما فعلا استفاده ش نمیکنیم
                    //val message = errorResponse.message

دسترسی به اون مپی که برای ارورز تعریف کردیم که فیلد داینامیک ما هست
                    val errors = errorResponse.errors
خب تا اینجای کار ما به اون مپه دسترسی پیدا کردیم. حالا دم بعدی چیه؟

ما خیلی راحت میتونیم مپ رو با فور ایچ پیمایش کنیم
پارامتر اولش key رو به ما میده و پارامتر دومش value
                    errors?.forEach { (key : String, value: List<String>) ->

نکته ای که اینجا هست اینه که ما لیست استرینگ هست ولیو هامون ولی استرینگ میخوایم
برای اینکه کاربر این کروشه ها رو نبینه []
خود لیست یک دستوری داره به اسم joinToString
کروشه اینا رو خودش پاک میکنه و یک استرینگ تمیز میده بمون
دستورات بیشتری هم برای کاستومایز بیشتر میتونیم بزنیم توش
                        errorMessage = value.joinToString()
                    }

                }

در نهایت ارور رو در قالب نتورک ریکوعست میدیم بیرون
                NetworkRequest.Error(errorMessage)
            }

ViewModel & LiveData--------------------------------------------------------------------------------
کار جدیدی که در این پروژه کردیم استفاده از انکپسولیشن در لایو دیتاهاست
همچنین ویومدل رو قبلا به این شکل تعریف میکردیم توی صفحه
    private val viewModel : LoginViewModel by viewModels()
    private val viewModel by viewModels<LoginViewModel>()
عینا شبیه هم هستن و برتری خاصی به هم ندارن اصلا

-------------------------------------------------------------------------تزریق وابستگی در دیتا کلاس ها
فرض کنید این کلاس رو داریم و میخوایم بتونیم تزریقش کنیم
data class BodyLogin(
    @SerializedName("login")
    val login: String?, //09120174757
    @SerializedName("hash_code")
    val hashCode: String?, //hjfvhzdbg#+
)

روش اول :
data class BodyLogin @Inject constructor(
    @SerializedName("login")
    val login: String?, //09120174757
    @SerializedName("hash_code")
    val hashCode: String?, //hjfvhzdbg#+
)

روش دوم: (اصولی تر)
بهتره بیایم این ها رو در قالب یک ماژول در نظر بگیریم
چرا؟
چون یک سری دیتا دارن معمولا که باید توی ورودی بهشون بدیم
مجبور نباشیم دستی هندل کنیم
به این منظور FragmentModule رو می سازیم
لایف سسایکل این ماژول هم به جای سینگل تون فرگمنت خواهد بود
دقت کنید چون باید مقداردهی اولیه صورت بگیرد مقادیر var بوده و مقدار اولیه null رو میدیم

extensions------------------------------------------------------------------------------------------
یک نکته ی نهایت مهم و کمیاب درمورد اکستنشن فانکشن ها
اگر اکستنشن فانکشنی رو دارید می نویسید که کارهای نسبتا سنگین تری رو داره انجام میده
و کدهای زیادی داره و روی ui کار میکنه
بهتره به صورت جداگانه نوشته شه
اکستنشن های  کوچیک و سبک رو توی همون فایل جنرال اکستنشن ها بنویسید

hide keyboard-----------------------------
fun View.hideKeyboard() {
    val imm = context.getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager
    imm.hideSoftInputFromWindow(windowToken, 0)
}
context :
وقتی اکستنشنن رو روی ویو مینویسیم خیلی راحت ببا کلمه context به کانتکس هم دسترسی داریم

getSystemService :
دسترسی به حالت هایی که توی سیستم من به عنوان سرویس وجود دارن

INPUT_METHOD_SERVICE :
یکی از این حالت ها اینپوت متد من هست که مربوط به کیبورد است
برای دسترسی بهش به کلاس کانتکس نیاز داریم

as InputMethodManager :
تبدیلش میکنیم به  InputMethodManager

windowToken :
توسط ویو بهش دسترسی داریم
 به همون صفحه ای که داریم باهاش کار میکنیم اشاره میکند

0 :
فلگ صفر کیبورد رو میبنده

Sealed class----------------------------------------------------------------------------------------
چون تما زیر مجموعه های سیلد کلاس از همون سیلد کلاس ساختته شدن با is میتونیم مقایسه کنیم
از is زمانی میتونیم استفاده کنیم که ارث بری صورت گرفته

Nested Nav graph------------------------------------------------------------------------------------
میخوایم استپ های مربوط به لاگین رو ببریم توی یک نویگیشن مستقل

select fragments -> RClick -> move to nested group -> new graph -> rename it

تو این روش فایل جدا ساخته نمیشه و تو همون فابل خودمون هستن
چالشی که این مدل درست میکنه دسترسی به فرگمنت های دخلی این ها هست
ارتباط بین نویگشن ها و ...
همه رو یاد میگیریم

Custom animation for navigation--------------------------------------------------------------------
Res -> R click -> new android resource directory -> anim

Timer-----------------------------------------------------------------------------------------------
برای نوشتن تایمر روش های مختلفی توی اندروید وجود داره
روشی که ما میخوایم استفاده کنیم اینه:
اندروید یک کلاسی داره به اسم CountDownTimer
یعنی یک عددی رو بهش میدید و میگید چند تا  چند تا بشمره
ما میخوایم 60 ثانیه رو به صورت یک ثانیه یک ثانیه به عقب بشمریم
بعد ما این عدد رو میدیم به پروگرس بار
----------------
برای استفاده از این تایمر ما باید یک بار استارتش کنیم
و نکته خیلی مهم این که فراموش نکنید کنسلش کنید
چون به شمردن ادامه میده همینجور... پرفورمنس رو میاره پایین
همینطور تو جا به جایی بین صفحات باید ریست شه تایمر اگه نه خیلی افتضاح میشه

         return object : CountDownTimer(60_000, 1_000) {
مقدار بازگشتی رو اینجور با آبجکت مینویسن!
توی اندروید همه چیز به صورت دیفالت میلی سکند هست
برای راحت تر خونده شدن اعداد آندرلاین میذاریم

دو تا متد داره که باید ایمپلمنت شن
onTick :
برای هر بار یک واحد میره جلو یک بار اجرا میشه
حالت لیسنر داره
اون عدد جاری رو هم بر اساس میلی ثانیه میده بمون

onFinish :
وقتی شمارش تمام شد صدا زده میشه

دکمه ارسال مجدد حین شمارش نامريی شه موقع پایان دیده شه
شمارنده حین شمارش دیده شود موقع پایان دیده نشود
پروگرس بار حین شمارش دیده شود موقع پایان دیده نشود
عدد رو نمایش میدیم و دایم آپدیت میکنیم

                @SuppressLint("SetTextI18n")
                override fun onTick(millis: Long) {
                    sendAgainBtn.isVisible = false
                    timerTxt.isVisible = true
                    timerProgress.isVisible = true
                    timerTxt.text = "${millis / 1000} ${getString(R.string.second)}"


میایم از setProgressCompat به جای setProgress استفاده میکنیم
چرا؟
چیزایی که کامپت دارن نسبت به تمام نسخه های اندروید بالا و پایین کامپتیبل شدن
بهینه سازی و ...
اگه کامپت میبینین ازش استفاده کنید
پارامتر دومش هم یک بولین هست که true یعنی با حالت انیمیشن این تغییر پروگرس انجام شه
                    timerProgress.setProgressCompat((millis / 1000).toInt(), true)
                    if (millis < 1000)
                        timerProgress.progress = 0
                }

                override fun onFinish() {
                    sendAgainBtn.isVisible = true
                    timerTxt.isVisible = false
                    timerProgress.isVisible = false
                    timerProgress.progress = 0
                }
            }
        }

حالا برای اینکه cpu رو درگیر نکنیم که هم زمان که داره پروسه رندر کردن صفحه رو انجام میده
تایمر رو هم هم زمان استارت بزنه
چه اتفاقی می افته اینجا؟
احتمالا یک لگ ریزی میزنه
برای جلوگیری از این وضعیت
یک دیلی ریز میندازیم بعد تایمر رو استارت میزیم

نکته:
همیشه خودتون خالی کردن رم و متغیرهای به درد نخور رو هندل کنید
تا گاربیج کالکتور مجبور نشه بیاد وارد عمل شه
چون گاربیج کالکتور که میاد دیگه لگ و هنگ و اینام هس
یه دلیلی که ما بایندینگ ها را نال میکنیم همینه
صفحه ای که یوزر ترکش کرده و قرار نیست برگرده بهش دلیلی نداره توی رم بمونه
مخصوصا موقع استفاده از سرویس ها مثل اس ام اس ریسیور
مثل تایمر


----------------------------------------------------------------بستن یک فرگمنت از داخل یک فرگمنت دیگه
                 findNavController().popBackStack(R.id.loginVerifyFragment , true)
                 findNavController().popBackStack(R.id.loginPhoneFragment , true)
بااین کد از داخل صفحه وریفای تمام صفحات لاگین رو از استک پاک کردیم

args with & without default value-------------------------------------------------------------------
اگر دیفالت ولیو ست نکنیم برای آرگز
به این شکل دایرکشن ساخته میشه
                            val direction = LoginPhoneFragmentDirections.actionLoginPhoneFragmentToLoginVerifyFragment(phone)
                            findNavController().navigate(direction)
ایراد این روش اینه که اگه به هر دلیل این آرگز فرستاده نشه کرش میکنیم
مثلا اگه اون فرگمنت هوم باشه

حالا اگر دیفالت ولیو ست کنیم دیگه با کد بالا نمیتونیم آرگز رو بفرستیم و ارور میگیریم
too many arguments...
باید چیکار کنیم؟
                            val direction = LoginPhoneFragmentDirections.actionLoginPhoneFragmentToLoginVerifyFragment().setMobile(phone)
                            findNavController().navigate(direction)

--------------------------------------------------------------باگ بک زدن در صفحه وریفای
ما یک لایو دیتا توی صفحه لاگین داریم که میگه
هر زمان ریسپانس ۲۰۰ اومد نویگیت کن به صفحه وریفای
خب در نتیجه هر زمان که از صفحه وریفای بک بزنیم به لاگین
ذات لایو دیتا اینه که آخرین دیتا رو پس میاره
یعنی دوباره همون لحظه ما رو میفرسته به وریفای
خب باید چیکار کرد توی اینجور مواقع؟

یک روش که قبلا یاد گرفتیم:
سینگل آبزرو کردن اون لایودیتا

یک روش ساده تر هم هست:
توی این روش خودمون میایم لاجیکش رو مینویسیم
فلگ گذاری:
حالا این فلگ رو کجا بذاریم که الکی هم مقدارش عوض نشه؟
تو خود فرگمنت که نمیشه گذاشت
توی اکتیویتی میشه گذاشت چون سینگل اکتیویتی هستیم
{من خودم توی ویومدل میذاشتم}
حالا ما میخوایم بیایم توی فایل کانستتنت بذاریمش
توی این روش توی کل اپلیکیشن توی مموری ساخته میشه و میمونه و بهش دسترسی داریم
IS_CALLED_VERIFY

moneySeparating Extension---------------------------------------------------------------------------
این اکستنشن برای سه رقم سه رقم جدا کردنن اعداد هستش

fun Int.moneySeparating(): String {
    return "${DecimalFormat("#,###.##").format(this)} تومان"
}

DecimalFormat :
یک کلاس جاوایی هست که میگه یک پترنی رو برای من مشخص کن
برای سه رقم سه رقم جدا کردن پترنش میشه شبیه پترن بالا
مثلا توی اپ های بانکی که شماره کارت ۴ رقم ۴ رقم جدا میشه هم با استفاده از همیناس
این پترن رو از کجا آوردیم؟
سرچ کنید...


