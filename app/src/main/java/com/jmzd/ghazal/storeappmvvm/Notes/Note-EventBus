Update profile entire application-------------------------------------------------------------------
یک راهش استفاده از اکتیویتی میومدل بود که توی فیلترهای سرچ استفاده کردیم
ولی گاهی این ویومدل مشترک رو نداریم
باید چیکار کرد؟
باید بیایم از یک ساز و کار خیلی حرفه ای دیگه استفاده کنیم
ایونت باس
یعنی هر اتفاقی هر جایی بیفته خیلی راحت میتونید مدیریتش کنید
اگه سرچش کنید یک کتابخونه داره
خیلی خفنه
ولی ما از این کتابخونه نمیخوایم استفاده کنیم
میخوایم سازوکارش رو درک کنیم
بعد بیایم با فلو پیاده سازیش کنیم
البته از خودشم خیلی راحت میتونیم استفاده کنیم
استارت و استاپش میکنید - تردش رو مشخص میکنید. ایونت رو سند میکنید یا دریافت میکنید

سازو کارش به طور خلاصه چیه؟
میگه اصلا مهم نیست که فرگمنت هات با هم در ارتباط باشن
مهم نیست لایف سایکل ویومدلت به چه شکله
میتونی صفحاتی که هیچ نقطه مشترکی با هم ندارن رو آپدیت کنی
با یک ایونت خاص

EventBus---------------------------------------------------------------------------------------------
سازوکار دقیقا شبیه لایودیتا هست
ولی به جای لایو دیتا از فلو استفاده میکنیم


object EventBus {

معادل همون لایودیتای پابلیک هست
راجب شیرد فلو توی فصل های قبل یاد گرفتیم!
از نوع any تعریف میکنیم که یعنی هر چیزی رو میشه توش فرستاد و جلوتر یاد میگیریم چرا
    private val events = MutableSharedFlow<Any>()


بعد میومدیم یک متغیر دیگه تعریف میکردیم
که این معادل همون لایودیتای پرایویت هست
    val usableEvent = events.asSharedFlow()

این متد هم که مشخصه چیکار میکنه - متد ارسال هست
برای امیت کردن باید ساسپند باشه
    suspend fun publish(event: Any) {
        events.emit(event)
    }

متد دریافت
چون دوباره داریم با فلو کار میکنیم باید ساسپند باشه
اکثر چیزای فلو با ساسپند هست
این درواقع همون ابزرور هست
یک فانکشن جنریک هست که ورودیشم یک لامبدا هست

filterIsInstance :
میاد یک فلویی رو برمیگردونه
که تایپش از نوع همون تایپی هست که بهش میدیم
بعد از اونجایی که این filterIsInstance میکه که
تایپ هایی که میگیره حتما باید از نوع reified باشن
پس ما هم T رو از نوع reified تعریف میکنیم
بعد reified که تعریف میکنیم میگه فانکشن هم پس باید inline باشه
ساز و کارش اینه دیگه

collectLatest:
ما اطلاعات رو توی فلو با کالکت دریافت میکردیم
الان آخریشو میخوایم فقط

coroutineContext.ensureActive()
اول باید مطمين شیم این کروتینی که داریم باش کار میکنیم زنده س و از بین نرفته

میگه چون فانکشنت به صورت اینلاین هست
پارامتر ورودیش هم باید به صورت کراس اینلاین باشه

    suspend inline fun <reified T> subscribe(crossinline onEvent: (T) -> Unit) {
        usableEvent.filterIsInstance<T>().collectLatest {
            coroutineContext.ensureActive()
            onEvent(it)
        }
    }
}