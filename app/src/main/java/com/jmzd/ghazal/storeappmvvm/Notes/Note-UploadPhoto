برای بارگذاری عکس پروفایل
https://shop.nouri-api.ir/api/v1/auth/avatar

دقت کنید که ۹۹٪ سرویس های مربوط به آپلود عکس از نوع پست هستن
اگه نبود به بک اند دولوپرتون شک کنید
مگر اینکه بخواد با base64 ببره جلو که به قدری استرینگ طولانی میشه که زیاد جالب نیست
پوت و پست مثل هم هستن. پوت برای آپدیت هست
پوت میاد override میکنه وقتی از قبل دیتایی باشه

ریسپانسی که از این api دریافت میشه به شکل زیر هست

"https://shop.nouri-api.ir/avatar/174.jpg?170324719890"

میبینید که برعکس سرویس هایی که تا الان داشتیم بدنه جیسون نداره

روش های آپلود عکس:----------------------------------------------------------------------------------
1- base 64
میاد چیکار میکنه؟
یک عکس رو به یک استرینگ خیلی بزرگ تبدیل میکنه
در حد چند صفحه
و هرچقدر حجم عکس بزرگتر باشه استرینگ بزرگتر میشه
خیلی سنگین میشه
و توی بادی هم میفرستیم این استرینگه رو
در کل روش خیلی ایده آلی نیست و روش بهتری داره

2- multipart form
اکثر اپلیکیشن های درست حسابی از این روش استفاده میکنن
فرض کنید یک عکس دارید ۵ مگابایته
هیچ موقع ما نمیایم یهو ۵۰۰ کیلو یک مگ اینا رو یه باره آپلود کنیم
آپلود سرعتش نسبت به دانلود خیلی کمه

فرض کنید یک جعبه میوه دارید که صد کیلوعه
نماید یه باره کلشو بلند کنید که
۱۰ کیلو ۱۰ کیلو برمیدارید و جا به جاش میکنید

مولتی پارت میاد چیکار میکنه؟
اینو تقسیم میکنه به پارت های خیلی خیلی کوچیک
در حد ۵۰ کیلو بایت و ۱۰۰ کیلو بایت
اینا رو میفرسته
در نهایت این تبدیل میشه به یک فایل ۱۰ مگابایتی

بعد اینم در نظر بگیرید
که حتی اگه عکس رو به صورت استرینگ بیس ۶۴ بفرستید
با ویدیو میخواید چیکار کنید؟
واسه همین مولتی پارت فرم خیلی خیلی کاراتر هست

این روشی که ما اینجا میگیم فقط مختص عکس نیست
و برای فرستادن فایل به صورت مالتی پارت هست
فایل میتونه پی دی اف یا موزیک یا ویدیو یا عکس یا هر چیزی باشه

model-----------------------------------------------------------------------------------------------
از اونجایی که ما جیسونی توی ریسپانس نداریم پس مدلی هم نداریم
یک استرینگ خالی است

api services----------------------------------------------------------------------------------------
ما قبلا بادی که میفرستادیم به صورت مدل میفرستادیم
الان میخوایم یاد بگیریم چیجوری بادی رو به صورت داینامیک بفرستیم
یعنی از قبل مشخص نباشه مدل
برا وقتایی کاربرد داره که چندین نوع بادی برای یک سرویس مشخص داریم
مثلا پارامترها را تحت شرایطی باید بفرستیم یا نباید بفرستیم
میشه یک مدل خیلی بزرگ ساخت در این مواقع برای هندل کردن همه حالت ها
ولی کد کثیف میشه
این روش داینامیک فرستادن بادی خیلی روش بهتریه
هر چیزی رو که اد کنی بهش برات میفرسته در این حالت

میایم تایپ بادی رو به جای مدل خاص از نوع ریکوعست بادی میذاریم
حواستون باشا اشتباهی تایپ رو ریسپانس بادی نذارید ها
ریکوعست بادی بعنی اون چیزی که دارم میفرستم
ریسپانس بادی اون چیزیه که برام میاد
ok http 3 هم هستن از کتابخونه

ریسپانس رو هم از نوع unit در نظر میگیریم
که معادل همون void هست در جاوا
یعنی هیچی

در نهایت به این شکل میشه
    @POST("auth/avatar")
    suspend fun uploadAvatar(@Body body : RequestBody) : Response<Unit>

این ریکوعست بادی رو خیلی جدی بگیرید چیز خیلی خفنیه
برای هندل کردن وضعیت های پیچیده خیلی به تمیز موندن کد کمک میکنه


شاید توی استک اور فلو و این ها دیده باشید که
میان مالتی پارت رو به صورت انوتیشن بالای انوتیشن پست مشخص میکنن
    @Multipart
    @POST("auth/avatar")
    suspend fun uploadAvatar(@Body body : RequestBody) : Response<Unit>
این هم درسته ولی ما نمیخوایم به صورت بالا مشخصش کنیم
چون میخوایم داینامیک بفرستیم
و مالتی پارت بودنش رو هم میخوایم به صورت داینامیک بفرستیم

این انوتیشن مالتی پارت رو اگه برای متد گت قرار بدی برات ارور نشون میده

ما حتی این انوتیشن رو هم به صورت داینامیک براش میفرستیم

ولی حتما باید مشخص کنیم براش. حالا استاتیک یا داینامیک

Image picker library--------------------------------------------------------------------------------
ما از این کتابخانه برای پیکر عکس استفاده میکنیم
https://github.com/SimformSolutionsPvtLtd/SSImagePicker

توی پروژه های زیادی ازش استفاده شده و خیلی راضی هستن
مخصوصا برای اندرویدهای بالاتر

چون همون طور که میدونید
توی اندروید ۱۰ دسترسی های استوریج تغییراتی داشته
توی ۱۱ یه خورده سخت ترش کرد
توی ۱۲ و ۱۳ دیگه زد واقعا سخت ترش کرد
که باید بیاید به کمک اسکوپ ها به استوریج دسترسی پیدا کنید
این لایبرری کامل همه این ها رو ساپورت میکنه
کلی فیچر خفن هم داره
روتیت - زوم - کراپ ...
مثلا دایره ای کراپ کردن
خیلی زحمت کشیدن براش

برای استفاده از این کتابخونه باید دیتابایندینگ پروژه تونم ترو کنید

نحوه استفاده:
1- activate data binding

2- add activity tag to manifest
باید بیاید اکتیویتی مربوط به این کتابخونه رو توی مانیفست اضافه کنید
با استفاده از کاستومایزی که توی داکیومنتش توضیح داده
میتونید مثلا رنگ ها و تم و ... رو عوض کنید توی پیکر

3- add listeners
برای استفاده از این پیکر باید بیاید لیسنرهاشو به فرگمنت با اکتیویتیون اضافه کنید
چی رو بهمون میده این لیسنر؟
عکسی که انتخاب کردیم
اگه نخوایم از این کتابخونه استفاده کنیم
این عکس رو در قالب onActivityResult بهمون برمیگردونه
که الانم onActivityResult دپریکیت شده
و یک روش دیگه ای اومده ولی سازوکار تقریبا همونه
ما دیگه از اون روش استفاده نمیکنیم چون کتابخونه همه شو هندل کرده
و مسیر عکس رو خیلی راحت به ما برمیگردونه

به شکل زیر میشه
@AndroidEntryPoint
class ProfileFragment : BaseFragment() , ImagePickerResultListener {

و متدهای زیر رو هم اورراید میکنه
    override fun onImagePick(uri: Uri?) {


    }

    override fun onMultiImagePick(uris: List<Uri>?) {
    }

یکیش برا وقتی یک عکس رو پیک میکنه یکیش برا وقتی چند تا عکس داریم
و خب داره uri هم برمیگردونه که چیزیه که نیاز داریم

onImagePick method----------------------------------------------------------------------------------

زمانی که عکس را از گالری گرفتید یا با دوربین گرفتید میاید توی این کد:
باید عکس رو در قالب یک فایل به سرور بفرستیم
این عکس که کاربر سلکت کرده رو باید تبدیل به اون فایل کنیم
چون این فایل رو به ما نمیده
uri میده
یو آر آی از اون حالتاییه که برای مسیردهی فایلا مورد استفاده قرار میگیره
و جزو مباحث خود اندروید هست
ما باید این یو آر آی رو تبدیل کنیم
روش های مختلفی برای تبدیل کردن مسیر به فایل وجود داره
اکثر این روش ها توی اندروید ۱۲ با مشکل رو به رو میشن
چون اندروید ۱۲ اومده کلا سازوکار استوریج رو تغییر داده و بر اساس اسکوپ رفته جلو
پس ما با روش های قدیمی نمیتونیم بریم جلو

قبلا میومدیم از onActivityResult استفاده میکردیم
بعد از انتخاب عکس یک مسیر استرینگ به ما میداد
که خیلی ساده و شسته رفته بود
File(path)
مسیر رو میدادیم به کلاس فایل و فایل ما ساخته میشد

ولی ما اینجا مسیر نداریم
یو آر آی داریم
و یو آر آی هم یک جور مسیره ولی به یک سبک دیگه ای
و ما نمیتونیم مستقیم از این استفاده کنیم برای ساختن فایل

path = مسیر واقعی
ولی از اندروید ۱۲ به بعد مسیر واقعی رو به ما نمیده
چون میخواد امنیتیش رو ببره بالاتر گوگل
میاد یک کانتنتی رو به ما میده
که توسط اون کانتنت شما باید بیاید به مسیر واقعی اون فایل دسترسی پیدا کنید
پس یو آر آی مسیر واقعی فایل نیست
چون اسکوپ کانتنت رو به ما میده نه مسیر واقعی

به این منظور یک اکستنشن مینویسیم

این فکر میکنم معادل همون کلاس RealPathUtil میشه که توی تموک داشتیم
این میاد مسیر رو از نوع استرینگ برمیگردونه

@SuppressLint("Range")
fun getRealFileFromUri(context: Context, uri: Uri): String? {

این متغیر در نهایت مسیر واقعی رو ریترن میکنه
    var result: String? = null

برای دسترسی به اون فایلی که دارم
اندروید یک متدی داره به اسم کانتنت ریسلور
توسط کانتنت رسیلور ما یو آر آی رو بهش میدیم
برامون کانتنت اون رو برمیگردونه
مثلا الان که کانتنتش رو داری برو دونه دونه فایلاش رو بخون و مسیرش رو برام ست کن

حالا چطور به کانتنت ریسلور دسترسی داشته باشیم؟
از طریق کانتکست
چون کانتنت ریسلور داخل کانتکس هست

حالا از متد کوعری استفاده میکنیم و یو آر آی رو بهش میدیم
یک سری پارامترهای دیگه هم میگیره که نیاز نداریم و نال میدیم
سلکشن و اردر و ...


    val resolver = context.contentResolver.query(uri, null, null, null, null)

    میگیم اگه ریسلور نال بود اطلاعات رو اینجوری بگیر
    یعنی پث رو از یو آر آی بگیر
    این برای اندرویدای زیر ۱۲ هست
    این کد تا اندروید ۱۳ رو ساپورت میکنه کاملا

    if (resolver == null) {
        result = uri.path
    } else {

    برای نسخه های دیگه اندروید
    باید این رسیلور رو پیمایش کنیم از اولش
    {اگه درست یادم بیاد از نوع کرسر بود که پیمایشش این شکلیه}
    قدیم توی اندروید با sql و این ها که کار میکردیم از کرسر استفاده میکردیم
    این ریسلور رو گاهی اسمش رو همون کرسر میذاره
    و کلا برای کار با محتوای فایل هست

    حالا میگیم برو دسترسی پیدا کن به اون ستونی که مال دیتای عکس های مدیا استور هست
    بعد از خوندن محتوای مد نظرتون کرسر رو کلوز کنید

        if (resolver.moveToFirst()) {
            result = resolver.getString(resolver.getColumnIndex(MediaStore.Images.ImageColumns.DATA))
        }
        resolver.close()
    }
    return result
}

کد بالا اندروید ۵ تا ۱۳ را ساپورت میکنه

----------------------------------------------

    override fun onImagePick(uri: Uri?) {

        با استفاده از اکستنشنمون فایل رو درست میکنیم اینجا

        val imageFile = getRealFileFromUri(requireContext(), uri!!)?.let { path -> File(path) }


        در مرحله بعد باید بیایم اون حالت داینامیک بادی رو بسازیم
        اینجا مالتی پارت هست بادیمون
        از MultipartBody.Builder() استفاده میکنیم
        با متد ست تایپ نوع رو مشخص میکنیم
        نوعمون MultipartBody.FORM هست اینجا
         همون فرم دیتا هست
         که توی پست من هم نشون میده
         مثلا بک اند دولوپر میگه من به صورت مالتی پارت و در قالب فرم دیتا میگیرم دیتا رو
         مثلا قالبای دیگه ای هم وجود داره
         parallel - digest - alternative -...

         بعد باید بیایم متدش رو مشخص کنیم
         که پست هست

        val multipart = MultipartBody.Builder().setType(MultipartBody.FORM)
            .addFormDataPart(METHOD, POST)

        حالا باید این فایلی که ساختیم رو در قالب کلید آواتار بفرستیم
        اینجا بادی رو داینامیک میسازیم
        URLEncoder = فایلی که داریم رو انکد میکنه برامون
        مسیر رو بهش میدیم
        بر اساس چه یونیکدی انکدش کنه؟
        میگیم utf-8
        این یونیکد کاراکترهای خاص مثل حروف فارسی رو ساپورت میکنه
        مثلا اگه اسم فایل ما فارسی باشه

        //Image body
        if (imageFile != null) {
            val fileName = URLEncoder.encode(imageFile.absolutePath, UTF_8)
            val reqFile = imageFile.asRequestBody(MULTIPART_FROM_DATA.toMediaTypeOrNull())

            در نهایت میگیم این بادی که ساختی رو
            با کلید آواتار
            و به صورت مالتی پارت فرم دیتا بفرس بره
            multipart.addFormDataPart(AVATAR, fileName, reqFile)
        }


        //Call api
        در نهایت چون مالتی پارت به صورت بیلدر هست میایم بیلدش رو صدا میزنیم
        val requestBody = multipart.build()
        if (isNetworkAvailable) {
            viewModel.callUploadAvatarApi(requestBody)
        }

    }

